function isObject(value) {
    return !!value && typeof value === 'object';
}
function isEqual(first, second) {
    return Object.entries(first).every(([key, value]) => (isObject(value) ? isEqual(second[key], value) : second[key] === value));
}

function getInstance(model, objectArguments) {
    ///resolution of issue https://github.com/rxweb/rxweb/issues/188
    return Reflect.construct(model, objectArguments);
}
function getObject(model, objectArguments, jObject) {
    let instance = getInstance(model, objectArguments);
    Object.keys(jObject).forEach(t => {
        instance[t] = jObject[t];
    });
    return instance;
}

class List {
    constructor(values, model) {
        this.model = model;
        this._entities = new Array();
        this.build(values);
    }
    [Symbol.iterator]() {
        let pointer = 0;
        let entities = this._entities;
        return {
            next() {
                if (pointer < entities.length) {
                    let index = pointer++;
                    if (this.model && entities[index].constructor !== this.model)
                        entities[index] = getObject(this.model, [], this.object[index]);
                    return {
                        done: false,
                        value: entities[index]
                    };
                }
                else {
                    return {
                        done: true,
                        value: null
                    };
                }
            }
        };
    }
    add(entity) {
        this._entities.push(this.createObject(entity));
    }
    addRange(entities) {
        for (let entity of entities)
            this.add(entity);
    }
    all(predicate) {
        return this._entities.every(predicate);
    }
    any(predicate) {
        return this._entities.some(predicate);
    }
    average(transform) {
        return this.sum(transform) / this.count(transform);
    }
    contains(element) {
        return this._entities.some(x => x === element);
    }
    concat(items) {
        if (items) {
            this.addRange(items);
            return new List(this._entities, this.model);
        }
        return undefined;
    }
    count(predicate) {
        return predicate ? this.where(predicate).count() : this._entities.length;
    }
    where(predicate) {
        return new List(this._entities.filter(predicate), this.model);
    }
    distinct() {
        return this.where((value, index, iter) => (isObject(value)) ?
            iter.findIndex(t => isEqual(t, value)) == index :
            iter.indexOf(value) === index);
    }
    distinctBy(keySelector) {
        const entityGroup = this.groupBy(keySelector);
        return Object.keys(entityGroup).reduce((resource, key) => {
            resource.add(entityGroup[key][0]);
            return resource;
        }, new List());
    }
    elementAt(index) {
        if (this._entities.length > index && index >= 0)
            return this._entities[index];
    }
    except(collection) {
        return this.where(x => !collection.contains(x));
    }
    first(predicate) {
        if (this.count()) {
            return predicate ? this.where(predicate).first() : this._entities[0];
        }
        else {
            throw new Error('No result found.');
        }
    }
    firstOrDefault(predicate) {
        return this.count() ? this.first(predicate) : undefined;
    }
    forEach(action) {
        return this._entities.forEach(action);
    }
    aggregate(accumulator, initialValue) {
        return this._entities.reduce(accumulator, initialValue);
    }
    groupBy(grouper, mapper) {
        if (!mapper)
            mapper = value => (value);
        return this.aggregate((ac, v) => (ac[grouper(v)] ? ac[grouper(v)].push(mapper(v)) : ac[grouper(v)] = [mapper(v)], ac), {});
    }
    insert(index, element) {
        if (index < 0 || index > this._entities.length) {
            throw new Error('Index is out of range.');
        }
        this._entities.splice(index, 0, this.createObject(element));
    }
    join(seperator) {
        return this._entities ? this._entities.join(seperator) : null;
    }
    last(predicate) {
        if (this.count()) {
            return predicate ? this.where(predicate).last() : this._entities[this.count() - 1];
        }
        else {
            throw Error('No result found.');
        }
    }
    lastOrDefault(predicate) {
        return this.count() ? this.last(predicate) : undefined;
    }
    get length() {
        return this._entities ? this._entities.length : 0;
    }
    max(predicate) {
        if (!predicate)
            return this.aggregate((x, y) => x > y ? x : y);
        else
            return Math.max(...this._entities.map(predicate));
    }
    maxBy(keySelector) {
        const entityGroup = this.groupBy(keySelector);
        let keys = Object.keys(entityGroup);
        let maxKey = Math.max(...keys);
        return entityGroup[maxKey][0];
    }
    min(predicate) {
        if (!predicate)
            return this.aggregate((x, y) => x < y ? x : y);
        else
            return Math.min(...this._entities.map(predicate));
    }
    minBy(keySelector) {
        const entityGroup = this.groupBy(keySelector);
        let keys = Object.keys(entityGroup);
        let minKey = Math.min(...keys);
        return entityGroup[minKey][0];
    }
    orderBy(predicate) {
        return new List(this._entities.sort(this.customSort(predicate, false)));
    }
    orderByDescending(predicate) {
        return new List(this._entities.sort(this.customSort(predicate, true)));
    }
    pop() {
        return this._entities.pop();
    }
    remove(element) {
        return this._entities.indexOf(element) !== -1 ? (this.removeAt(this._entities.indexOf(element)), true) : false;
    }
    removeAll(predicate) {
        return this.where(this._negate(predicate));
    }
    removeAt(index) {
        this._entities.splice(index, 1);
    }
    reverse() {
        return this._entities ? new List(this._entities.reverse(), this.model) : new List();
    }
    select(mapper) {
        return this._entities.map(mapper);
    }
    single(predicate) {
        if (this.count() !== 1) {
            throw new Error('Item does not contain one element.');
        }
        else {
            return this.first(predicate);
        }
    }
    singleOrDefault(predicate) {
        return this.count() ? this.first(predicate) : undefined;
    }
    shift() {
        return this._entities ? this._entities.shift() : undefined;
    }
    skip(amount) {
        return this._entities.slice(Math.max(0, amount));
    }
    sum(transform) {
        return transform ? this.select(transform).sum() : this.aggregate((ac, v) => ac += (+v), 0);
    }
    take(amount) {
        return this._entities.slice(0, Math.max(0, amount));
    }
    get toLocaleString() {
        return this._entities ? this._entities.toLocaleString() : null;
    }
    get toString() {
        return this._entities ? this._entities.toString() : null;
    }
    _negate(predicate) {
        return function () {
            return !predicate.apply(this, arguments);
        };
    }
    customSort(predicate, orderByDescending) {
        return (a, b) => {
            const first = predicate(a);
            const second = predicate(b);
            if (first > second) {
                return !orderByDescending ? 1 : -1;
            }
            else if (first < second) {
                return !orderByDescending ? -1 : 1;
            }
            else {
                return 0;
            }
        };
    }
    build(values) {
        if (values && values.length > 0) {
            this.addRange(values);
        }
    }
    createObject(object) {
        if (this.model && object.constructor !== this.model)
            return getObject(this.model, [], object);
        return object;
    }
}

export { List };
//# sourceMappingURL=rxweb-generics.js.map
