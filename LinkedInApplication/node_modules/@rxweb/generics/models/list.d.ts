import { Type } from '../functions/type';
export declare class List<T> {
    private model?;
    private _entities;
    constructor(values?: T[], model?: Type<T>);
    [Symbol.iterator](): Iterator<T>;
    add(entity: T): void;
    addRange(entities: T[]): void;
    all(predicate: (value?: T, index?: number, list?: T[]) => boolean): boolean;
    any(predicate: (value?: T, index?: number, list?: T[]) => boolean): boolean;
    average(transform?: (value?: T, index?: number, list?: T[]) => any): number;
    contains(element: T): boolean;
    concat(items: T[]): List<T>;
    count(predicate?: (value?: T, index?: number, list?: T[]) => boolean): number;
    where(predicate: (value?: T, index?: number, list?: T[]) => boolean): List<T>;
    distinct(): List<T>;
    distinctBy(keySelector: (key: T) => string | number): List<T>;
    elementAt(index: number): T;
    except(collection: List<T>): List<T>;
    first(predicate?: (value?: T, index?: number, list?: T[]) => boolean): T | Error;
    firstOrDefault(predicate?: (value?: T, index?: number, list?: T[]) => boolean): T | Error;
    forEach(action: (value?: T, index?: number, list?: T[]) => any): void;
    aggregate<U>(accumulator: (accum: U, value?: T, index?: number, list?: T[]) => any, initialValue?: U): any;
    groupBy(grouper: (key: T) => any, mapper?: (element: T) => any): any;
    insert(index: number, element: T): void | Error;
    join(seperator?: string): string;
    last(predicate?: (value?: T, index?: number, list?: T[]) => boolean): T | Error;
    lastOrDefault(predicate?: (value?: T, index?: number, list?: T[]) => boolean): T | Error;
    readonly length: number;
    max(): number;
    max(predicate: (value: T, index: number, list: T[]) => number): number;
    maxBy(keySelector: (key: T) => number): T;
    min(): number;
    min(predicate: (value: T, index: number, list: T[]) => number): number;
    minBy(keySelector: (key: T) => number): T;
    orderBy(predicate: (key: T) => any): List<T>;
    orderByDescending(predicate: (key: T) => any): List<T>;
    pop(): T | undefined;
    remove(element: T): boolean;
    removeAll(predicate: (value?: T, index?: number, list?: T[]) => boolean): List<T>;
    removeAt(index: number): void;
    reverse(): List<T>;
    select(mapper: (value?: T, index?: number, list?: T[]) => any): any;
    single(predicate?: (value?: T, index?: number, list?: T[]) => boolean): T | Error;
    singleOrDefault(predicate?: (value?: T, index?: number, list?: T[]) => boolean): T | Error;
    shift(): T | undefined;
    skip(amount: number): T[];
    sum(transform?: (value?: T, index?: number, list?: T[]) => number): number;
    take(amount: number): List<T>;
    readonly toLocaleString: string;
    readonly toString: string;
    private _negate;
    private customSort;
    private build;
    private createObject;
}
