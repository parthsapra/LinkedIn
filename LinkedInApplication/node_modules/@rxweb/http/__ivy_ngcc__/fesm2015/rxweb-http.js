import { Observable } from 'rxjs';

function isFormData(formValue) {
    return typeof FormData !== 'undefined' && formValue instanceof FormData;
}
function isBlob(formValue) {
    return typeof Blob !== 'undefined' && formValue instanceof Blob;
}
function isArrayBuffer(formValue) {
    return typeof ArrayBuffer !== 'undefined' && formValue instanceof ArrayBuffer;
}
//copied from : https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/getAllResponseHeaders
function extractHeaders(headers) {
    var arr = headers.trim().split(/[\r\n]+/);
    var headerMap = {};
    arr.forEach(function (line) {
        var parts = line.split(': ');
        var header = parts.shift();
        var value = parts.join(': ');
        headerMap[header] = value;
    });
    return headerMap;
}

function createQueryPath(config) {
    return `${getParams(config)}${getQueryParams(config)}`;
}
function getParams(config) {
    let params = '';
    if (config && config.params && config.params.length > 0)
        params = `/${config.params.join('/')}`;
    return params;
}
function getQueryParams(config) {
    let queryParams = '?';
    if (config && config.queryParams)
        Object.keys(config.queryParams).forEach(key => {
            queryParams += `${key}=${config.queryParams[key]}&`;
        });
    return queryParams.slice(0, queryParams.length - 1);
}

class HttpRequest {
    constructor(body, headers, host, isHttps, method, path, params, queryParams, responseType, scheme, fullPath) {
        this.body = body;
        this.headers = headers;
        this.host = host;
        this.method = method;
        this.path = path;
        this.params = params;
        this.queryParams = queryParams;
        this.responseType = responseType;
        this.scheme = scheme;
        if (!responseType)
            this.responseType = 'json';
        this.isHttps = isHttps;
        if (fullPath)
            this.fullPath = fullPath;
    }
    get isHttps() {
        return this._isHttps;
    }
    set isHttps(value) {
        this._isHttps = value;
        if (value)
            this.fullPath = this.fullPath.replace("http:", "https:");
    }
    get fullPath() {
        return this._fullPath ? this._fullPath : `${this.host}/${this.path}${createQueryPath({ params: this.params, queryParams: this.queryParams })}`;
    }
    set fullPath(value) {
        this._fullPath = value;
    }
    getContentType() {
        if (this.body === null) {
            return null;
        }
        if (isFormData(this.body)) {
            return null;
        }
        if (isBlob(this.body)) {
            return this.body.type || null;
        }
        if (isArrayBuffer(this.body)) {
            return null;
        }
        if (typeof this.body === 'string') {
            return 'text/plain';
        }
        if (typeof this.body === 'object' || typeof this.body === 'number' ||
            Array.isArray(this.body)) {
            return 'application/json';
        }
        return null;
    }
    serializeBody() {
        if (this.body === null) {
            return null;
        }
        if (isArrayBuffer(this.body) || isBlob(this.body) || isFormData(this.body) ||
            typeof this.body === 'string') {
            return this.body;
        }
        if (this.method == 'PATCH')
            this.body = this.convertPatchBody(this.body);
        if (typeof this.body === 'object' || typeof this.body === 'boolean' ||
            Array.isArray(this.body)) {
            return JSON.stringify(this.body);
        }
        if (this.body)
            return String(this.body);
        return '';
    }
    convertPatchBody(object) {
        let patchBody = [];
        for (var col in object) {
            patchBody.push({
                'op': 'replace',
                'path': '/' + col,
                'value': object[col]
            });
        }
        return patchBody;
    }
}

function requestBody(method, baseConfig, serviceContainer, config, instance) {
    if (!(typeof config == "string")) {
        let uri = getHostUri(baseConfig, serviceContainer, config);
        let path = (config && config.path) ? config.path : serviceContainer.config.path;
        let isHttps = uri.startsWith("https://");
        return new HttpRequest(config ? config.body : undefined, {}, uri, isHttps, method, path, config && config.params ? config.params : [], config && config.queryParams ? config.queryParams : {}, config ? config.responseType : undefined, isHttps ? 'https' : 'http');
    }
    else {
        let isHttps = config.startsWith("https://");
        return new HttpRequest(undefined, {}, config, config.startsWith("https://"), method, config, [], {}, undefined, isHttps ? 'https' : 'http', config);
    }
}
function getHostUri(baseConfig, serviceContainer, config) {
    if (config && config.hostUri)
        return config.hostUri;
    if (serviceContainer && serviceContainer.config && serviceContainer.config.hostKey)
        return baseConfig.hostURIs.filter(t => t.name == serviceContainer.config.hostKey)[0].uri;
    if (baseConfig.hostURIs)
        return baseConfig.hostURIs.filter(t => t.default == true)[0].uri;
    return window.location.origin;
}

const httpRequestContainer = new (class {
    constructor() {
        this.serviceContainers = new Array();
    }
    register(target, config, type) {
        let serviceContainer = this.serviceContainers.filter(t => t.target == target && t.type == type)[0];
        if (!serviceContainer)
            this.serviceContainers.push({ target: target, config: config, type: type });
    }
    registerConfig(httpClientConfig) {
        this.baseConfig = httpClientConfig;
    }
    get(target) {
        return this.serviceContainers.filter(t => t.target == target);
    }
    getConfig() {
        return this.baseConfig;
    }
})();

function getInstanceContainer(instance) {
    let container = httpRequestContainer.get(instance.constructor);
    let prototype = (!container || container.length == 0) ? instance.__proto__ : {};
    if (prototype.__proto__) {
        let isLoop = false;
        do {
            isLoop = prototype.__proto__.constructor != Object;
            if (isLoop) {
                container = httpRequestContainer.get(prototype.__proto__.constructor);
                isLoop = container == undefined;
            }
        } while (isLoop);
    }
    return container;
}

class HttpResponse {
    constructor() { }
}

class XhrContext {
    constructor(request, response) {
        this.request = request;
        this.response = response;
        if (!this.response)
            this.response = new HttpResponse();
    }
    set result(value) {
        this._result = value;
        this.response.isInMemoryResponse = true;
    }
    get result() {
        return this._result;
    }
}

class AbstractRequestFilter {
}

class XhrRequest {
    constructor(request, onComplete, onRequestError, badRequest) {
        this.request = request;
        this.onComplete = onComplete;
        this.onRequestError = onRequestError;
        this.badRequest = badRequest;
        this.onLoad = () => {
            let response = new HttpResponse();
            response.statusCode = this.xhr.status;
            response.statusText = this.xhr.statusText || 'OK';
            response.headers = extractHeaders(this.xhr.getAllResponseHeaders());
            response.responseUrl = this.xhr.responseURL;
            let body = null;
            if (response.statusCode !== 204)
                body = typeof this.xhr.response === 'undefined' ? this.xhr.responseText : this.xhr.response;
            if (response.statusCode === 0)
                response.statusCode = !!body ? 200 : 0;
            let isSuccess = response.statusCode >= 200 && response.statusCode < 300;
            if (this.request.responseType === 'json' && response.headers["content-type"] && response.headers["content-type"].indexOf("json") != -1 && typeof body === 'string') {
                const originalBody = body;
                body = body.replace(/^\)\]\}',?\n/, '');
                try {
                    body = body !== '' ? JSON.parse(body) : null;
                }
                catch (ex) {
                    body = originalBody;
                    if (isSuccess) {
                        isSuccess = false;
                        body = { ex, body: body };
                    }
                }
            }
            response.body = body;
            if (isSuccess) {
                this.onComplete(response);
                this.dispose();
            }
            else
                this.onError(response);
        };
        this.onError = (error) => {
            if (this.xhr.status == 400 && this.badRequest)
                this.badRequest(typeof this.xhr.response === 'undefined' ? this.xhr.responseText : this.xhr.response);
            else if (this.onRequestError)
                this.onRequestError({
                    responseUrl: this.xhr.responseURL,
                    error: error,
                    statusCode: this.xhr.status || 0,
                    statusText: this.xhr.statusText || 'Unknown Error'
                });
            else
                console.error(error);
            this.dispose();
        };
        let xhr = new XMLHttpRequest();
        xhr.open(request.method, request.fullPath);
        Object.keys(request.headers).forEach(t => xhr.setRequestHeader(t, request.headers[t]));
        if (!request.headers['Accept'])
            xhr.setRequestHeader('Accept', 'application/json, text/plain, */*');
        if (!request.headers['Content-Type']) {
            const contentType = request.getContentType();
            if (contentType !== null) {
                xhr.setRequestHeader('Content-Type', contentType);
            }
        }
        xhr.addEventListener('load', this.onLoad);
        xhr.addEventListener('error', this.onError);
        xhr.withCredentials = true;
        xhr.send(request.serializeBody());
        this.xhr = xhr;
    }
    dispose() {
        if (this.xhr) {
            this.xhr.removeEventListener('load', this.onLoad);
            this.xhr.removeEventListener('error', this.onError);
        }
        this.xhr = null;
        this.request = null;
        this.onComplete = null;
        this.onRequestError = null;
        this.badRequest = null;
    }
}

function createInstance(model, objectArguments) {
    let classInstance = Object.create(model.prototype);
    try {
        model.apply(classInstance, objectArguments);
    }
    catch (ex) {
        ///resolution of issue https://github.com/rxweb/rxweb/issues/188
        classInstance = Reflect.construct(model, objectArguments);
    }
    return classInstance;
}

class RxHttpResponse {
    constructor(request, filters, inMemoryFilter, onError, badRequest) {
        this.request = request;
        this.filters = filters;
        this.inMemoryFilter = inMemoryFilter;
        this.onError = onError;
        this.badRequest = badRequest;
        this._index = 0;
        this._onResponse = new Array();
        this.onRequestExecuting = () => {
            return (context) => {
                if (context.response.statusCode) {
                    let response = Object.assign({}, context.response, { body: context.result });
                    if (response.statusCode >= 200 && response.statusCode < 300)
                        this._onSuccess(response);
                    else {
                        this._onError.error(response);
                        this.onError(response);
                    }
                }
                else
                    this.executeFilterOnRequest();
            };
        };
    }
    process(type, success) {
        this._onSuccess = this.onComplete(type, success);
        this._onError = success;
        this.inMemoryFilter ? this.callFilter(this.inMemoryFilter) : this.executeFilterOnRequest();
    }
    executeFilterOnRequest() {
        if (this.filters && this.filters.length > 0 && this.filters.length > this._index) {
            this.callFilter(this.filters[this._index]);
        }
        else
            new XhrRequest(this.request, this._onSuccess, this.onRequestError.bind(this), this.badRequest);
    }
    callFilter(filterConfig) {
        if (!filterConfig.runsOn || filterConfig.runsOn.indexOf(this.request.method) != -1) {
            let modelInstance = createInstance(filterConfig.model, filterConfig.args || []);
            modelInstance.onRequestExecuting = this.onRequestExecuting();
            this._index++;
            modelInstance.onRequest(new XhrContext(this.request, new HttpResponse()));
            if (modelInstance["onResponse"])
                this._onResponse.push(modelInstance);
        }
        else
            this._index++;
    }
    onComplete(resultType, onSuccess) {
        return (response) => {
            if (this._onResponse.length > 0 && !response.isInMemoryResponse)
                this._onResponse.forEach(t => t.onResponse(response));
            onSuccess.next(response.body);
            onSuccess.complete();
        };
    }
    onRequestError(response) {
        this._onError.error(response);
        if (this.onError)
            this.onError(response);
    }
}

class RxHttp {
    constructor() {
    }
    getFilters() {
        let filters = (this._baseConfig && this._baseConfig.filters) ? this._baseConfig.filters : [];
        let filterService = this._serviceContainers.filter(t => t.type == "filter")[0];
        let requestFilters = [];
        if (filterService)
            filterService.config.forEach(t => requestFilters.push(t));
        filters.forEach(t => requestFilters.push(t));
        return requestFilters;
    }
    getInMemoryFilter() {
        let inMemory = this._serviceContainers.filter(t => t.type == "inmemory")[0];
        if (inMemory && this._baseConfig && this._baseConfig.filters)
            return this._baseConfig.filters.filter(t => t.isInMemory)[0];
        return null;
    }
    request(method, config) {
        return new Observable(subscriber => {
            if (!this._baseConfig)
                this._baseConfig = httpRequestContainer.getConfig() || {};
            if (!this._serviceContainers)
                this._serviceContainers = getInstanceContainer(this);
            let serviceContainer = this._serviceContainers.filter(t => t.type == "http")[0];
            let request = requestBody(method, this._baseConfig, serviceContainer, config);
            if (request) {
                let error = this._baseConfig ? this._baseConfig.onError : null;
                let response = new RxHttpResponse(request, this.getFilters(), this.getInMemoryFilter(), this.onError || error, this.badRequest);
                response.process('subscribe', subscriber);
            }
            else {
                subscriber.next(null);
                subscriber.complete();
            }
        });
    }
    lookup(configs) {
        return new Observable(subscriber => {
            let propNames = [];
            let subscriptions = [];
            let jObject = {};
            configs.forEach(t => {
                propNames.push(t.propName);
                subscriptions.push(this.get(t).subscribe(X => {
                    jObject[t.propName] = X;
                    if (Object.keys(jObject).length == propNames.length) {
                        subscriber.next(jObject);
                        subscriber.complete();
                    }
                }));
            });
        });
    }
    get(config) {
        return this.request('GET', config);
    }
    post(config) {
        return this.request('POST', config);
    }
    put(config) {
        return this.request('PUT', config);
    }
    patch(config) {
        return this.request('PATCH', config);
    }
    delete(config) {
        return this.request('DELETE', config);
    }
}

function http(config) {
    return function (target) {
        httpRequestContainer.register(target, config, "http");
    };
}

function xhrFilter(config) {
    return function (target) {
        httpRequestContainer.register(target, config, "filter");
    };
}

function inMemory() {
    return function (target) {
        httpRequestContainer.register(target, null, "inmemory");
    };
}

class HttpClientConfig {
    static register(config) {
        httpRequestContainer.registerConfig(config);
    }
}

export { AbstractRequestFilter, HttpClientConfig, HttpResponse, RxHttp, XhrContext, http, inMemory, xhrFilter };

//# sourceMappingURL=rxweb-http.js.map