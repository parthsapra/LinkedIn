import { __spread, __decorate, __metadata, __extends } from 'tslib';
import { Injectable, Injector, Input, Directive, ViewContainerRef, TemplateRef, NgModule } from '@angular/core';
import { ActivatedRoute, Router, RouterLinkWithHref } from '@angular/router';
import { LocationStrategy, NgIfContext } from '@angular/common';
import { RxHttp } from '@rxweb/http';
import { ClientDataStorage } from '@rxweb/storage';

var routeContainer = new (/** @class */ (function () {
    function class_1() {
        this.state = {};
        this.modelDecorators = new Array();
    }
    class_1.prototype.add = function (routerConfig) {
        this.state = routerConfig;
    };
    class_1.prototype.get = function () {
        return this.state;
    };
    class_1.prototype.getUser = function () {
        return this.user;
    };
    class_1.prototype.setUser = function (user) {
        this.user = user;
    };
    class_1.prototype.addModelDecorator = function (target, data, type) {
        this.modelDecorators.push({ target: target, functions: data, type: type });
    };
    class_1.prototype.getModelDecorator = function (target, type) {
        return this.modelDecorators.filter(function (t) { return t.target == target && t.type == type; })[0];
    };
    return class_1;
}()))();

function authResolver(injector, next) {
    return function (anonymous) {
        if (!anonymous) {
            var authResolverModel = routeContainer.get().authentication;
            if (authResolverModel) {
                var authResolver = injector.get(authResolverModel);
                var result = authResolver.resolveAuth();
                if (result instanceof Promise) {
                    result.then(function (t) {
                        routeContainer.setUser(t);
                        next(t);
                    });
                }
                else {
                    routeContainer.setUser(result);
                    next(result);
                }
            }
            else
                next(result);
        }
        else
            next(result);
    };
}

var componentInstanceProvider = new (/** @class */ (function () {
    function class_1() {
        this.instances = new Array();
    }
    class_1.prototype.broadCastParamChange = function (params) {
        if (Object.keys(params).length > 0)
            this.instances.forEach(function (t) {
                t.paramChanged(params);
            });
    };
    class_1.prototype.broadCastQueryParamChange = function (queryParams) {
        if (Object.keys(queryParams).length > 0)
            this.instances.forEach(function (t) {
                t.queryParamChanged(queryParams);
            });
    };
    class_1.prototype.setComponentRoute = function (route, router) {
        this.activatedRouteSnapshot = route;
        this.router = router;
        this.broadCastParamChange(route.params);
        this.broadCastQueryParamChange(route.queryParams);
    };
    class_1.prototype.setAuthroizeConfig = function (config) {
        this.authorizeConfig = config;
    };
    class_1.prototype.getAuthorizeConfig = function () {
        return this.authorizeConfig;
    };
    class_1.prototype.getResult = function () {
        return {
            activatedRouteSnapshot: this.activatedRouteSnapshot,
            router: this.router,
            authorizeConfig: this.authorizeConfig
        };
    };
    class_1.prototype.getActivatedRouteSnapshot = function () {
        return this.activatedRouteSnapshot;
    };
    class_1.prototype.getRouter = function () {
        return this.router;
    };
    class_1.prototype.add = function (name, resolver, paramChanged, queryParamChanged) {
        this.instances.push({ name: name, resolver: resolver, paramChanged: paramChanged, queryParamChanged: queryParamChanged });
    };
    class_1.prototype.resolve = function (target) {
        var instance = this.instances.filter(function (t) { return t.name == target.name; })[0];
        if (instance)
            return instance.resolver();
        throw new Error("Component instance is not available");
    };
    class_1.prototype.dispose = function (target) {
        var instances = this.instances.filter(function (t) { return t.name == target.name; });
        var length = instances.length;
        for (var i = 0; i < length; i++)
            instances.splice(0, 1);
    };
    return class_1;
}()))();

function authorize(injector, route, next, complete) {
    var component = routeContainer.getModelDecorator(route.component, "access");
    var anonymous = routeContainer.getModelDecorator(route.component, "anonymous");
    //if (!component && !anonymous)
    //    throw `Define anyone (@anonymous() or @access({...})) decorator on the route component `;
    if (component) {
        var authorizeModel = routeContainer.get().authorization;
        if (authorizeModel) {
            var authorize = injector.get(authorizeModel);
            var result = authorize.authorize(component.functions, route);
            if (result instanceof Promise) {
                result.then(function (t) {
                    if (t)
                        componentInstanceProvider.setAuthroizeConfig(component.functions), next(anonymous);
                    else
                        complete(false);
                });
            }
            else if (result === true)
                componentInstanceProvider.setAuthroizeConfig(component.functions), next(anonymous);
            else
                complete(result);
        }
        else
            next(anonymous);
    }
    else
        next(anonymous);
}

function middleware(injector, route, complete) {
    return function (user) {
        var middlewareModels = routeContainer.get().middlewares;
        var modelMiddleware = routeContainer.getModelDecorator(route.component, "middleware");
        if (modelMiddleware)
            middlewareModels = middlewareModels ? __spread(middlewareModels, modelMiddleware.functions) : __spread(modelMiddleware.functions);
        if (middlewareModels)
            callFunction(user, injector, route, complete, middlewareModels);
        else
            complete(true);
    };
}
function callFunction(user, injector, route, complete, middlewareModels, count) {
    count = count == undefined ? 0 : count + 1;
    var middleware = injector.get(middlewareModels[count]);
    if (middleware) {
        var result = middleware.invoke(user, route);
        if (result instanceof Promise) {
            result.then(function (t) {
                if (t) {
                    if (middlewareModels.length > (count + 1))
                        callFunction(user, injector, route, complete, middlewareModels, count);
                    else
                        complete(t);
                }
                else
                    complete(t);
            });
        }
        else if (result && middlewareModels.length > (count + 1))
            callFunction(user, injector, route, complete, middlewareModels, count);
        else
            complete(result);
    }
    else
        complete(true);
}

var encoder = new (/** @class */ (function () {
    function class_1() {
    }
    class_1.prototype.decode = function (value) {
        value = value.replace("00", "=").replace("00", "=");
        var text = atob(value);
        return text;
    };
    class_1.prototype.encode = function (value) {
        var text = btoa(value).replace("=", "00").replace("=", "00");
        return text;
    };
    return class_1;
}()))();

function paramsDecryption(route) {
    var isEncryption = routeContainer.get().urlEncryption;
    if (isEncryption) {
        var params = {};
        Object.keys(route.params).forEach(function (t) {
            var value = encoder.decode(route.params[t]);
            Object.defineProperty(params, t, {
                get: function () { return value; },
            });
        });
        delete route.params;
        route.params = Object.preventExtensions(params);
    }
}

var ParamResolver = /** @class */ (function () {
    function ParamResolver(activatedRoute, router) {
        this.activatedRoute = activatedRoute;
        this.router = router;
    }
    ParamResolver = __decorate([
        Injectable(),
        __metadata("design:paramtypes", [ActivatedRoute, Router])
    ], ParamResolver);
    return ParamResolver;
}());

var BaseCanActivate = /** @class */ (function () {
    function BaseCanActivate(injector, paramResolver) {
        this.injector = injector;
        this.paramResolver = paramResolver;
    }
    BaseCanActivate.prototype.canActivate = function (route, state) {
        var _this = this;
        var promise = new Promise(function (r, reject) {
            paramsDecryption(route);
            var resolve = _this.resolveRoute(r, route);
            authorize(_this.injector, route, authResolver(_this.injector, middleware(_this.injector, route, resolve)), resolve);
        });
        return promise;
    };
    BaseCanActivate.prototype.resolveRoute = function (resolve, route) {
        var _this = this;
        return function (value) {
            if (value)
                componentInstanceProvider.setComponentRoute(route, _this.injector.get(Router));
            resolve(value);
        };
    };
    BaseCanActivate = __decorate([
        Injectable(),
        __metadata("design:paramtypes", [Injector, ParamResolver])
    ], BaseCanActivate);
    return BaseCanActivate;
}());

var BaseCanDeactivate = /** @class */ (function () {
    function BaseCanDeactivate() {
    }
    BaseCanDeactivate.prototype.canDeactivate = function (component, currentRoute, currentState, nextState) {
        return (component.canDeactivate) ? component.canDeactivate(currentRoute, currentState, nextState) : true;
    };
    BaseCanDeactivate = __decorate([
        Injectable(),
        __metadata("design:paramtypes", [])
    ], BaseCanDeactivate);
    return BaseCanDeactivate;
}());

function routePath(path) {
    var splitText = path.split('/');
    var path = "";
    splitText.forEach(function (t) {
        var isParam = t.charAt(0) == ":";
        if (path == "" && isParam)
            path = t;
        else if (isParam)
            path += "/" + t;
        else if (path === "")
            path += "" + encoder.encode(t);
        else
            path += "/" + encoder.encode(t);
    });
    return path;
}

var RouteProvider = /** @class */ (function () {
    function RouteProvider() {
    }
    RouteProvider.addRoute = function (route) {
        this.addCanActivate(route);
        this.addCanDeactivate(route);
        this._routes.push(route);
    };
    RouteProvider.applyRootRoutes = function (_routes) {
        this.routes = [];
        var routes = _routes || __spread(this._routes);
        var isAllowEncryption = routeContainer.get().urlEncryption;
        if (isAllowEncryption) {
            routes.forEach(function (route) {
                route.path = routePath(route.path);
            });
        }
        this._routes = [];
        this.routes = routes;
    };
    RouteProvider.addCanActivate = function (route) {
        if (!route.canActivate)
            route.canActivate = [BaseCanActivate];
        else
            route.canActivate.push(BaseCanActivate);
    };
    RouteProvider.addCanDeactivate = function (route) {
        if (!route.canDeactivate)
            route.canDeactivate = [BaseCanDeactivate];
        else
            route.canDeactivate.push(BaseCanDeactivate);
    };
    RouteProvider.routes = [];
    RouteProvider._routes = [];
    return RouteProvider;
}());

function route(route) {
    return function (target) {
        route.component = target;
        RouteProvider.addRoute(route);
    };
}

function middleware$1(middlewares) {
    return function (target) {
        routeContainer.addModelDecorator(target, middlewares, "middleware");
    };
}

function access(authorizeConfig) {
    return function (target) {
        routeContainer.addModelDecorator(target, authorizeConfig, "access");
    };
}

function routerModule(routerConfig) {
    return function (target) {
        routeContainer.add(routerConfig);
    };
}

function anonymous() {
    return function (target) {
        routeContainer.addModelDecorator(target, null, "anonymous");
    };
}

var ExtendRouterLinkWithHref = /** @class */ (function (_super) {
    __extends(ExtendRouterLinkWithHref, _super);
    function ExtendRouterLinkWithHref(router, activatedRoute, locationStratergy) {
        var _this = _super.call(this, router, activatedRoute, locationStratergy) || this;
        _this.isPushed = false;
        _this.overrideProp();
        return _this;
    }
    ExtendRouterLinkWithHref.prototype.overrideProp = function () {
        var value = [];
        Object.defineProperty(this, "commands", {
            get: function () {
                var isEncryption = routeContainer.get().urlEncryption;
                if (Array.isArray(value) && Array.isArray(this.params) && !this.isPushed) {
                    this.params.forEach(function (t) {
                        var encode = isEncryption ? encoder.encode(t) : t;
                        value.push(encode);
                    });
                    this.isPushed = true;
                }
                return value;
            },
            set: function (v) {
                value = v;
            }
        });
    };
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], ExtendRouterLinkWithHref.prototype, "params", void 0);
    ExtendRouterLinkWithHref = __decorate([
        Directive({ selector: 'a[routerLink],area[routerLink]' }),
        __metadata("design:paramtypes", [Router, ActivatedRoute, LocationStrategy])
    ], ExtendRouterLinkWithHref);
    return ExtendRouterLinkWithHref;
}(RouterLinkWithHref));

var RxAuthorizeDirective = /** @class */ (function () {
    function RxAuthorizeDirective(viewContainerRef, templateRef, injector) {
        this.viewContainerRef = viewContainerRef;
        this.templateRef = templateRef;
        this.injector = injector;
        this.viewRef = null;
        this._context = new NgIfContext();
    }
    Object.defineProperty(RxAuthorizeDirective.prototype, "component", {
        set: function (value) {
            if (Array.isArray(value)) {
                this._components = value;
                this.checkAuth(0);
            }
            else if (value)
                this.checkAccess(value);
        },
        enumerable: true,
        configurable: true
    });
    RxAuthorizeDirective.prototype.checkAuth = function (index) {
        if (this._components.length > index) {
            this.checkAccess(this._components[index], index);
        }
        else {
            this.updateView(true);
        }
    };
    RxAuthorizeDirective.prototype.checkAccess = function (value, currentIndex) {
        var _this = this;
        if (currentIndex === void 0) { currentIndex = 0; }
        var authorizeModel = routeContainer.get().authorization;
        var component = routeContainer.getModelDecorator(value, "access");
        if (authorizeModel && component) {
            var authorize = this.injector.get(authorizeModel);
            var authorizeConfig = componentInstanceProvider.getAuthorizeConfig();
            var result = authorize.authorizeChildren(component.functions, authorizeConfig);
            if (typeof result === "boolean") {
                if (this._components && this._components.length > 0 && result) {
                    var index = currentIndex + 1;
                    this.checkAuth(index);
                }
                else
                    this.updateView(result);
            }
            else
                result.then(function (t) {
                    if (t) {
                        var index = currentIndex + 1;
                        _this.checkAuth(index);
                    }
                    else
                        _this.updateView(t);
                });
        }
    };
    RxAuthorizeDirective.prototype.updateView = function (value) {
        if (this.viewRef) {
            this.viewContainerRef.clear();
            this.viewRef = null;
        }
        if (value)
            this.viewRef = this.viewContainerRef.createEmbeddedView(this.templateRef, this._context);
        else
            this.viewContainerRef.clear();
    };
    __decorate([
        Input('rxAuthorize'),
        __metadata("design:type", Object),
        __metadata("design:paramtypes", [Object])
    ], RxAuthorizeDirective.prototype, "component", null);
    RxAuthorizeDirective = __decorate([
        Directive({
            selector: '[rxAuthorize]'
        }),
        __metadata("design:paramtypes", [ViewContainerRef, TemplateRef, Injector])
    ], RxAuthorizeDirective);
    return RxAuthorizeDirective;
}());

var RxMultilingualDirective = /** @class */ (function () {
    function RxMultilingualDirective(viewContainerRef, templateRef, injector) {
        this.viewContainerRef = viewContainerRef;
        this.templateRef = templateRef;
        this.injector = injector;
        this.viewRef = null;
        this._context = new NgIfContext();
    }
    Object.defineProperty(RxMultilingualDirective.prototype, "component", {
        set: function (value) {
            var _this = this;
            var childMultiLingual = routeContainer.get().childMultilingualResolver;
            if (childMultiLingual) {
                var childMultilingual = this.injector.get(childMultiLingual);
                var result = childMultilingual.resolveChildren(this.viewContainerRef["_view"].component.constructor);
                if (typeof result == "boolean")
                    this.updateView(result);
                else
                    result.then(function (t) {
                        _this.updateView(t);
                    });
            }
        },
        enumerable: true,
        configurable: true
    });
    RxMultilingualDirective.prototype.updateView = function (value) {
        if (this.viewRef) {
            this.viewContainerRef.clear();
            this.viewRef = null;
        }
        if (value)
            this.viewRef = this.viewContainerRef.createEmbeddedView(this.templateRef, this._context);
        else
            this.viewContainerRef.clear();
    };
    __decorate([
        Input('rxMultilingual'),
        __metadata("design:type", Object),
        __metadata("design:paramtypes", [Object])
    ], RxMultilingualDirective.prototype, "component", null);
    RxMultilingualDirective = __decorate([
        Directive({
            selector: '[rxMultilingual]'
        }),
        __metadata("design:paramtypes", [ViewContainerRef, TemplateRef, Injector])
    ], RxMultilingualDirective);
    return RxMultilingualDirective;
}());

var RxRoutingModule = /** @class */ (function () {
    function RxRoutingModule() {
    }
    RxRoutingModule = __decorate([
        NgModule({
            declarations: [ExtendRouterLinkWithHref, RxAuthorizeDirective, RxMultilingualDirective],
            exports: [ExtendRouterLinkWithHref, RxAuthorizeDirective, RxMultilingualDirective],
            providers: [BaseCanActivate, BaseCanDeactivate, ParamResolver]
        })
    ], RxRoutingModule);
    return RxRoutingModule;
}());

var AuthorizeConfig = /** @class */ (function () {
    function AuthorizeConfig() {
    }
    return AuthorizeConfig;
}());

function routes(routes) {
    var _routes = [];
    routes.forEach(function (t) {
        if (t.path)
            t.path = routePath(t.path);
        if (t.redirectTo)
            t.redirectTo = routePath(t.redirectTo);
        _routes.push(t);
    });
    return _routes;
}

var CoreComponent = /** @class */ (function (_super) {
    __extends(CoreComponent, _super);
    function CoreComponent() {
        var _this = _super.call(this) || this;
        var result = componentInstanceProvider.getResult();
        if (result && result.activatedRouteSnapshot) {
            _this.params = result.activatedRouteSnapshot.params;
            _this.queryParams = result.activatedRouteSnapshot.queryParams;
            _this.navigation = result.router;
            _this.user = routeContainer.getUser();
            _this.data = result.activatedRouteSnapshot.data;
            _this.storage = new ClientDataStorage();
            _this.parentAuthorizeConfig = result.authorizeConfig;
            var decoratorConfig = routeContainer.getModelDecorator(_this.constructor, "access");
            if (decoratorConfig)
                _this.authorizeConfig = decoratorConfig.functions;
            componentInstanceProvider.add(_this.constructor.name, _this.instanceProvider.bind(_this), _this.paramsChange.bind(_this), _this.queryParamsChange.bind(_this));
        }
        return _this;
    }
    CoreComponent.prototype.onQueryParamsChanged = function () { };
    CoreComponent.prototype.onParamsChanged = function () { };
    CoreComponent.prototype.instanceProvider = function () {
        return this;
    };
    CoreComponent.prototype.resolve = function (component) {
        return componentInstanceProvider.resolve(component.constructor);
    };
    CoreComponent.prototype.navigate = function (commands, extras) {
        return this.navigation.navigate(commands.concat(this.getParsedParams(extras)), extras);
    };
    CoreComponent.prototype.ngOnDestroy = function () {
        componentInstanceProvider.dispose(this.constructor);
    };
    CoreComponent.prototype.paramsChange = function (params) {
        this.params = params;
        this.onParamsChanged();
    };
    CoreComponent.prototype.queryParamsChange = function (queryParams) {
        this.queryParams = queryParams;
        this.onQueryParamsChanged();
    };
    CoreComponent.prototype.getParsedParams = function (extras) {
        var params = [];
        if (extras && extras.params) {
            var isEncryption = routeContainer.get().urlEncryption;
            extras.params.forEach(function (t) {
                var encode = isEncryption ? encoder.encode(t) : t;
                params.push(encode);
            });
        }
        return params;
    };
    return CoreComponent;
}(RxHttp));

export { AuthorizeConfig, BaseCanActivate, BaseCanDeactivate, CoreComponent, RouteProvider, RxRoutingModule, access, anonymous, middleware$1 as middleware, route, routerModule, routes, ExtendRouterLinkWithHref as ɵa, RxAuthorizeDirective as ɵb, RxMultilingualDirective as ɵc, ParamResolver as ɵd };
//# sourceMappingURL=rxweb-angular-router.js.map
