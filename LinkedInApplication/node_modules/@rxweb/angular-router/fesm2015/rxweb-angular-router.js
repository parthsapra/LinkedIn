import { __decorate, __metadata } from 'tslib';
import { Injectable, Injector, Input, Directive, ViewContainerRef, TemplateRef, NgModule } from '@angular/core';
import { ActivatedRoute, Router, RouterLinkWithHref } from '@angular/router';
import { LocationStrategy, NgIfContext } from '@angular/common';
import { RxHttp } from '@rxweb/http';
import { ClientDataStorage } from '@rxweb/storage';

const routeContainer = new (class {
    constructor() {
        this.state = {};
        this.modelDecorators = new Array();
    }
    add(routerConfig) {
        this.state = routerConfig;
    }
    get() {
        return this.state;
    }
    getUser() {
        return this.user;
    }
    setUser(user) {
        this.user = user;
    }
    addModelDecorator(target, data, type) {
        this.modelDecorators.push({ target: target, functions: data, type: type });
    }
    getModelDecorator(target, type) {
        return this.modelDecorators.filter(t => t.target == target && t.type == type)[0];
    }
})();

function authResolver(injector, next) {
    return (anonymous) => {
        if (!anonymous) {
            var authResolverModel = routeContainer.get().authentication;
            if (authResolverModel) {
                var authResolver = injector.get(authResolverModel);
                var result = authResolver.resolveAuth();
                if (result instanceof Promise) {
                    result.then(t => {
                        routeContainer.setUser(t);
                        next(t);
                    });
                }
                else {
                    routeContainer.setUser(result);
                    next(result);
                }
            }
            else
                next(result);
        }
        else
            next(result);
    };
}

const componentInstanceProvider = new (class {
    constructor() {
        this.instances = new Array();
    }
    broadCastParamChange(params) {
        if (Object.keys(params).length > 0)
            this.instances.forEach(t => {
                t.paramChanged(params);
            });
    }
    broadCastQueryParamChange(queryParams) {
        if (Object.keys(queryParams).length > 0)
            this.instances.forEach(t => {
                t.queryParamChanged(queryParams);
            });
    }
    setComponentRoute(route, router) {
        this.activatedRouteSnapshot = route;
        this.router = router;
        this.broadCastParamChange(route.params);
        this.broadCastQueryParamChange(route.queryParams);
    }
    setAuthroizeConfig(config) {
        this.authorizeConfig = config;
    }
    getAuthorizeConfig() {
        return this.authorizeConfig;
    }
    getResult() {
        return {
            activatedRouteSnapshot: this.activatedRouteSnapshot,
            router: this.router,
            authorizeConfig: this.authorizeConfig
        };
    }
    getActivatedRouteSnapshot() {
        return this.activatedRouteSnapshot;
    }
    getRouter() {
        return this.router;
    }
    add(name, resolver, paramChanged, queryParamChanged) {
        this.instances.push({ name: name, resolver: resolver, paramChanged: paramChanged, queryParamChanged: queryParamChanged });
    }
    resolve(target) {
        let instance = this.instances.filter(t => t.name == target.name)[0];
        if (instance)
            return instance.resolver();
        throw new Error("Component instance is not available");
    }
    dispose(target) {
        let instances = this.instances.filter(t => t.name == target.name);
        let length = instances.length;
        for (var i = 0; i < length; i++)
            instances.splice(0, 1);
    }
})();

function authorize(injector, route, next, complete) {
    let component = routeContainer.getModelDecorator(route.component, "access");
    let anonymous = routeContainer.getModelDecorator(route.component, "anonymous");
    //if (!component && !anonymous)
    //    throw `Define anyone (@anonymous() or @access({...})) decorator on the route component `;
    if (component) {
        var authorizeModel = routeContainer.get().authorization;
        if (authorizeModel) {
            var authorize = injector.get(authorizeModel);
            var result = authorize.authorize(component.functions, route);
            if (result instanceof Promise) {
                result.then(t => {
                    if (t)
                        componentInstanceProvider.setAuthroizeConfig(component.functions), next(anonymous);
                    else
                        complete(false);
                });
            }
            else if (result === true)
                componentInstanceProvider.setAuthroizeConfig(component.functions), next(anonymous);
            else
                complete(result);
        }
        else
            next(anonymous);
    }
    else
        next(anonymous);
}

function middleware(injector, route, complete) {
    return (user) => {
        var middlewareModels = routeContainer.get().middlewares;
        var modelMiddleware = routeContainer.getModelDecorator(route.component, "middleware");
        if (modelMiddleware)
            middlewareModels = middlewareModels ? [...middlewareModels, ...modelMiddleware.functions] : [...modelMiddleware.functions];
        if (middlewareModels)
            callFunction(user, injector, route, complete, middlewareModels);
        else
            complete(true);
    };
}
function callFunction(user, injector, route, complete, middlewareModels, count) {
    count = count == undefined ? 0 : count + 1;
    var middleware = injector.get(middlewareModels[count]);
    if (middleware) {
        var result = middleware.invoke(user, route);
        if (result instanceof Promise) {
            result.then(t => {
                if (t) {
                    if (middlewareModels.length > (count + 1))
                        callFunction(user, injector, route, complete, middlewareModels, count);
                    else
                        complete(t);
                }
                else
                    complete(t);
            });
        }
        else if (result && middlewareModels.length > (count + 1))
            callFunction(user, injector, route, complete, middlewareModels, count);
        else
            complete(result);
    }
    else
        complete(true);
}

const encoder = new (class {
    decode(value) {
        value = value.replace("00", "=").replace("00", "=");
        var text = atob(value);
        return text;
    }
    encode(value) {
        let text = btoa(value).replace("=", "00").replace("=", "00");
        return text;
    }
})();

function paramsDecryption(route) {
    var isEncryption = routeContainer.get().urlEncryption;
    if (isEncryption) {
        var params = {};
        Object.keys(route.params).forEach(t => {
            let value = encoder.decode(route.params[t]);
            Object.defineProperty(params, t, {
                get: function () { return value; },
            });
        });
        delete route.params;
        route.params = Object.preventExtensions(params);
    }
}

let ParamResolver = class ParamResolver {
    constructor(activatedRoute, router) {
        this.activatedRoute = activatedRoute;
        this.router = router;
    }
};
ParamResolver = __decorate([
    Injectable(),
    __metadata("design:paramtypes", [ActivatedRoute, Router])
], ParamResolver);

let BaseCanActivate = class BaseCanActivate {
    constructor(injector, paramResolver) {
        this.injector = injector;
        this.paramResolver = paramResolver;
    }
    canActivate(route, state) {
        var promise = new Promise((r, reject) => {
            paramsDecryption(route);
            let resolve = this.resolveRoute(r, route);
            authorize(this.injector, route, authResolver(this.injector, middleware(this.injector, route, resolve)), resolve);
        });
        return promise;
    }
    resolveRoute(resolve, route) {
        return (value) => {
            if (value)
                componentInstanceProvider.setComponentRoute(route, this.injector.get(Router));
            resolve(value);
        };
    }
};
BaseCanActivate = __decorate([
    Injectable(),
    __metadata("design:paramtypes", [Injector, ParamResolver])
], BaseCanActivate);

let BaseCanDeactivate = class BaseCanDeactivate {
    constructor() { }
    canDeactivate(component, currentRoute, currentState, nextState) {
        return (component.canDeactivate) ? component.canDeactivate(currentRoute, currentState, nextState) : true;
    }
};
BaseCanDeactivate = __decorate([
    Injectable(),
    __metadata("design:paramtypes", [])
], BaseCanDeactivate);

function routePath(path) {
    var splitText = path.split('/');
    var path = "";
    splitText.forEach(t => {
        let isParam = t.charAt(0) == ":";
        if (path == "" && isParam)
            path = t;
        else if (isParam)
            path += `/${t}`;
        else if (path === "")
            path += `${encoder.encode(t)}`;
        else
            path += `/${encoder.encode(t)}`;
    });
    return path;
}

class RouteProvider {
    static addRoute(route) {
        this.addCanActivate(route);
        this.addCanDeactivate(route);
        this._routes.push(route);
    }
    static applyRootRoutes(_routes) {
        this.routes = [];
        var routes = _routes || [...this._routes];
        var isAllowEncryption = routeContainer.get().urlEncryption;
        if (isAllowEncryption) {
            routes.forEach(route => {
                route.path = routePath(route.path);
            });
        }
        this._routes = [];
        this.routes = routes;
    }
    static addCanActivate(route) {
        if (!route.canActivate)
            route.canActivate = [BaseCanActivate];
        else
            route.canActivate.push(BaseCanActivate);
    }
    static addCanDeactivate(route) {
        if (!route.canDeactivate)
            route.canDeactivate = [BaseCanDeactivate];
        else
            route.canDeactivate.push(BaseCanDeactivate);
    }
}
RouteProvider.routes = [];
RouteProvider._routes = [];

function route(route) {
    return function (target) {
        route.component = target;
        RouteProvider.addRoute(route);
    };
}

function middleware$1(middlewares) {
    return function (target) {
        routeContainer.addModelDecorator(target, middlewares, "middleware");
    };
}

function access(authorizeConfig) {
    return function (target) {
        routeContainer.addModelDecorator(target, authorizeConfig, "access");
    };
}

function routerModule(routerConfig) {
    return function (target) {
        routeContainer.add(routerConfig);
    };
}

function anonymous() {
    return function (target) {
        routeContainer.addModelDecorator(target, null, "anonymous");
    };
}

let ExtendRouterLinkWithHref = class ExtendRouterLinkWithHref extends RouterLinkWithHref {
    constructor(router, activatedRoute, locationStratergy) {
        super(router, activatedRoute, locationStratergy);
        this.isPushed = false;
        this.overrideProp();
    }
    overrideProp() {
        var value = [];
        Object.defineProperty(this, "commands", {
            get: function () {
                var isEncryption = routeContainer.get().urlEncryption;
                if (Array.isArray(value) && Array.isArray(this.params) && !this.isPushed) {
                    this.params.forEach(t => {
                        let encode = isEncryption ? encoder.encode(t) : t;
                        value.push(encode);
                    });
                    this.isPushed = true;
                }
                return value;
            },
            set: function (v) {
                value = v;
            }
        });
    }
};
__decorate([
    Input(),
    __metadata("design:type", Array)
], ExtendRouterLinkWithHref.prototype, "params", void 0);
ExtendRouterLinkWithHref = __decorate([
    Directive({ selector: 'a[routerLink],area[routerLink]' }),
    __metadata("design:paramtypes", [Router, ActivatedRoute, LocationStrategy])
], ExtendRouterLinkWithHref);

let RxAuthorizeDirective = class RxAuthorizeDirective {
    constructor(viewContainerRef, templateRef, injector) {
        this.viewContainerRef = viewContainerRef;
        this.templateRef = templateRef;
        this.injector = injector;
        this.viewRef = null;
        this._context = new NgIfContext();
    }
    set component(value) {
        if (Array.isArray(value)) {
            this._components = value;
            this.checkAuth(0);
        }
        else if (value)
            this.checkAccess(value);
    }
    checkAuth(index) {
        if (this._components.length > index) {
            this.checkAccess(this._components[index], index);
        }
        else {
            this.updateView(true);
        }
    }
    checkAccess(value, currentIndex = 0) {
        var authorizeModel = routeContainer.get().authorization;
        let component = routeContainer.getModelDecorator(value, "access");
        if (authorizeModel && component) {
            var authorize = this.injector.get(authorizeModel);
            var authorizeConfig = componentInstanceProvider.getAuthorizeConfig();
            var result = authorize.authorizeChildren(component.functions, authorizeConfig);
            if (typeof result === "boolean") {
                if (this._components && this._components.length > 0 && result) {
                    let index = currentIndex + 1;
                    this.checkAuth(index);
                }
                else
                    this.updateView(result);
            }
            else
                result.then(t => {
                    if (t) {
                        let index = currentIndex + 1;
                        this.checkAuth(index);
                    }
                    else
                        this.updateView(t);
                });
        }
    }
    updateView(value) {
        if (this.viewRef) {
            this.viewContainerRef.clear();
            this.viewRef = null;
        }
        if (value)
            this.viewRef = this.viewContainerRef.createEmbeddedView(this.templateRef, this._context);
        else
            this.viewContainerRef.clear();
    }
};
__decorate([
    Input('rxAuthorize'),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], RxAuthorizeDirective.prototype, "component", null);
RxAuthorizeDirective = __decorate([
    Directive({
        selector: '[rxAuthorize]'
    }),
    __metadata("design:paramtypes", [ViewContainerRef, TemplateRef, Injector])
], RxAuthorizeDirective);

let RxMultilingualDirective = class RxMultilingualDirective {
    constructor(viewContainerRef, templateRef, injector) {
        this.viewContainerRef = viewContainerRef;
        this.templateRef = templateRef;
        this.injector = injector;
        this.viewRef = null;
        this._context = new NgIfContext();
    }
    set component(value) {
        let childMultiLingual = routeContainer.get().childMultilingualResolver;
        if (childMultiLingual) {
            var childMultilingual = this.injector.get(childMultiLingual);
            var result = childMultilingual.resolveChildren(this.viewContainerRef["_view"].component.constructor);
            if (typeof result == "boolean")
                this.updateView(result);
            else
                result.then(t => {
                    this.updateView(t);
                });
        }
    }
    updateView(value) {
        if (this.viewRef) {
            this.viewContainerRef.clear();
            this.viewRef = null;
        }
        if (value)
            this.viewRef = this.viewContainerRef.createEmbeddedView(this.templateRef, this._context);
        else
            this.viewContainerRef.clear();
    }
};
__decorate([
    Input('rxMultilingual'),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], RxMultilingualDirective.prototype, "component", null);
RxMultilingualDirective = __decorate([
    Directive({
        selector: '[rxMultilingual]'
    }),
    __metadata("design:paramtypes", [ViewContainerRef, TemplateRef, Injector])
], RxMultilingualDirective);

let RxRoutingModule = class RxRoutingModule {
};
RxRoutingModule = __decorate([
    NgModule({
        declarations: [ExtendRouterLinkWithHref, RxAuthorizeDirective, RxMultilingualDirective],
        exports: [ExtendRouterLinkWithHref, RxAuthorizeDirective, RxMultilingualDirective],
        providers: [BaseCanActivate, BaseCanDeactivate, ParamResolver]
    })
], RxRoutingModule);

class AuthorizeConfig {
}

function routes(routes) {
    let _routes = [];
    routes.forEach(t => {
        if (t.path)
            t.path = routePath(t.path);
        if (t.redirectTo)
            t.redirectTo = routePath(t.redirectTo);
        _routes.push(t);
    });
    return _routes;
}

class CoreComponent extends RxHttp {
    onQueryParamsChanged() { }
    onParamsChanged() { }
    constructor() {
        super();
        let result = componentInstanceProvider.getResult();
        if (result && result.activatedRouteSnapshot) {
            this.params = result.activatedRouteSnapshot.params;
            this.queryParams = result.activatedRouteSnapshot.queryParams;
            this.navigation = result.router;
            this.user = routeContainer.getUser();
            this.data = result.activatedRouteSnapshot.data;
            this.storage = new ClientDataStorage();
            this.parentAuthorizeConfig = result.authorizeConfig;
            let decoratorConfig = routeContainer.getModelDecorator(this.constructor, "access");
            if (decoratorConfig)
                this.authorizeConfig = decoratorConfig.functions;
            componentInstanceProvider.add(this.constructor.name, this.instanceProvider.bind(this), this.paramsChange.bind(this), this.queryParamsChange.bind(this));
        }
    }
    instanceProvider() {
        return this;
    }
    resolve(component) {
        return componentInstanceProvider.resolve(component.constructor);
    }
    navigate(commands, extras) {
        return this.navigation.navigate(commands.concat(this.getParsedParams(extras)), extras);
    }
    ngOnDestroy() {
        componentInstanceProvider.dispose(this.constructor);
    }
    paramsChange(params) {
        this.params = params;
        this.onParamsChanged();
    }
    queryParamsChange(queryParams) {
        this.queryParams = queryParams;
        this.onQueryParamsChanged();
    }
    getParsedParams(extras) {
        let params = [];
        if (extras && extras.params) {
            var isEncryption = routeContainer.get().urlEncryption;
            extras.params.forEach(t => {
                let encode = isEncryption ? encoder.encode(t) : t;
                params.push(encode);
            });
        }
        return params;
    }
}

export { AuthorizeConfig, BaseCanActivate, BaseCanDeactivate, CoreComponent, RouteProvider, RxRoutingModule, access, anonymous, middleware$1 as middleware, route, routerModule, routes, ExtendRouterLinkWithHref as ɵa, RxAuthorizeDirective as ɵb, RxMultilingualDirective as ɵc, ParamResolver as ɵd };
//# sourceMappingURL=rxweb-angular-router.js.map
